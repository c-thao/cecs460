; CHOU THAO
; 012647516
; CECS 460
; TRANSMIT ASSEMBLY
; This assembly code will echo back a
; character it receives as well as be
; able to transmit for special cases

; EQU go here for register names
; NUMBER EQUS
ZEROES  EQU 0000 
ONE     EQU 0001
TWO     EQU 0002
THREE   EQU 0003
FOUR    EQU 0004
FIVE    EQU 0005
DELAY   EQU BA03
MAX     EQU 0028
LDCHK   EQU 0080
BS      EQU 0008
CR      EQU 000D
PMTCHK  EQU 0010
BNCHK   EQU 0014
HTCHK   EQU 0020
AST     EQU 002A
AT      EQU 0040

; REGISTER EQUS
SCRATCH EQU R0 ; USED TO STORE INITIAL SCRATCH RAM DATA
PTR     EQU R1 ; POINTER TO STACK RAM
COMM    EQU R3 ; LOAD REGISTER FOR TX & RX
COUNTN  EQU R4 ; NOP COUNTER
COUNTER EQU R5 ; COUNT REGISTER
LEDS    EQU R6 ; LEDS
TEMP    EQU R7 ; TEMP REGISTER
NVAL    EQU R8 ; VALID REGISTER FOR NOP COUNTER
STAT    EQU R9 ; STATUS REGISTER
ERROR   EQU RA ; ERROR REGISTER
TSTA    EQU RB ; TRANSMIT STATE REGISTER
QUOT    EQU RC ; QUOTIENT FROM DIVISION
DIV     EQU RD ; DIVIDER AMOUNT
VALID   EQU RE ; VALID REGISTER FOR DIGIT TO BEGIN
TCHK    EQU RF ; TRANSMIT CHECK

; INITIALIZATION
; ENABLE INTERRUPTS
START   
        ENINT
        LOAD STAT, ZEROES    ; INITIALIZE STAT WITH 0
        LOAD TSTA, FOUR      ; INITIALIZE TSTA WITH 4
        LOAD PTR, ZEROES     ; INITIALIZE PTR TO ADDRESS 0
        LOAD COMM, ZEROES    ; INITIALIZE COMM REGISTER TO 0
        LOAD COUNTN, ZEROES  ; INITIALIZE COUNTN REGISTER TO 0
        LOAD COUNTER, ZEROES ; INITIALIZE COUNTER REGISTER TO 0
        LOAD NVAL, ZEROES    ; INITIALIZE NVAL REGISTER TO 0
        LOAD LEDS, ONE       ; INITIALIZE LEDS WITH 1
        CALL BANINIT         ; BANNER INITIALIZATION
        CALL PMTINIT         ; PROMPT INITIALIZATION
        CALL HTINIT          ; HOMETOWN INITIALIZATION
        CALL BSINIT          ; BS INITIALIZATION
        CALL BINTOHEX        ; COUNTER HEXASCII

; main
LOOP
        OUTPUT LEDS, ONE     ; UPDATE LEDS
        COMP   LEDS, LDCHK   ; CHECK IF LEDS ARE AT 8
        JUMPNZ LEDSUP
        LOAD   LEDS, ONE     ; RESET LEDS TO 1
        JUMP   LDOUT

LEDSUP
        RL LEDS              ; ROTATE LEDS TO THE LEFT

LDOUT
        CALL NON             ; CALL DELAY ROUTINE
        JUMP LOOP            
        

; ISR ADDRESS
        ADDRESS 0300

; INTERRUPT SERVICE ROUTINE
ISR     
; CHECK IF TRANSMITING EXTRAS
        STORE  PTR, 0031       ; SCR[65] <- PTR
        INPUT  STAT, ONE       ; READ IN STATUS FLAGS

; CHECK IF TXRDY IS HIGH
        LOAD   TEMP, STAT      ; TEMP <- STAT
        COMP   TSTA, ZEROES    ; CHECK IF DONE TRANSMITTING
        JUMPZ  RXCHK           ; IF LOW CHECK RXRDY

        AND    TEMP, TWO       ; OBTAIN TXRDY STATUS
        COMP   TEMP, TWO       ; CHECK IF TXRDY HIGH
        JUMPNZ EISR            ; EXIT

PRTCHK
        COMP   TSTA, FIVE      ; CHECK IF TSTA IS 5        
        JUMPZ  PRINT           ; CONTINUE TRANSMIT

; HOMETOWN PRINT
        COMP   TSTA, TWO       ; CHECK IF TSTA IS 2
        JUMPNZ TTRI            ; ELSE CHECK FOR 3
        LOAD   TCHK, 001E      ; TCHK <- 30
        LOAD   TSTA, FIVE      ; TSTA <- 5
        JUMP   PRINT           ; GO PRINT

; PROMPT PRINT
TTRI
        COMP   TSTA, THREE     ; CHECK IF TSTA IS 3
        JUMPNZ TQUAD           ; ELSE CHECK FOR 4
        LOAD   TCHK, 0014      ; TCHK <- 20
        LOAD   TSTA, FIVE      ; TSTA <- 5
        JUMP   PRINT           ; GO PRINT

; BANNER PRINT
TQUAD
        COMP   TSTA, FOUR      ; CHECK IF TSTA IS 4
        JUMPNZ EISR            ; ELSE EXIT
        LOAD   TCHK, 000E      ; TCHK <- 14
        LOAD   TSTA, FIVE      ; TSTA <- 5
        LOAD   PTR, ZEROES     ; PTR <- 0;
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   PRINT
  
RXCHK
        LOAD   TEMP, STAT      ; TEMP <- STAT      
        AND    TEMP, ONE       ; OBTAIN RXRDY STATUS
        COMP   TEMP, ONE       ; CHECK IF RXRDY HIGH
        JUMPNZ EISR            ; IF LOW RETURN

; OBTAIN ERROR
        LOAD   ERROR, STAT     ; ERROR <- STAT
        AND    ERROR, 001C     ; OBTAIN ERROR STATUS
        OUTPUT ERROR, TWO      ; UPDATE ERROR STATUS

; READ IN DATA RECEIVED
; AND TRANSMIT IT BACK
        INPUT  COMM, ZEROES    ; READ IN NEW DATA
        COMP   COUNTER, 0028   ; CHECK IF COUNTER IS 40
        JUMPZ  EISR            ; IF TRUE EXIT 
        LOAD   TEMP, COMM      ; TEMP <- COMM

; CHECK FOR CR
CRCHK
        COMP   TEMP, CR        ; CHECK IF TEMP IS <CR>
        JUMPNZ BSCHK         
        LOAD   TSTA, THREE     ; TSTA <- 3
        LOAD   PTR, 000E       ; PTR <- 14
        FETCH  COMM, (PTR)     ; COMM <- SCR[14]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR BS
BSCHK
        COMP   TEMP, BS        ; CHECK IF TEMP IS <BS>
        JUMPNZ ASTCHK         
        COMP   COUNTER, ZEROES ; CHECK IF COUNTER IS 0
        JUMPZ  EISR            ; EXIT IF TRUE
        LOAD   TSTA, FIVE      ; TSTA <- 5
        SUB    COUNTER, ONE    ; DECREMENT COUNTER
        LOAD   TCHK, 0021      ; TCHK <- 33
        LOAD   PTR, 001E       ; PTR <- 30
        FETCH  COMM, (PTR)     ; COMM <- SCR[30]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR *
ASTCHK
        COMP   TEMP, AST       ; CHECK IF TEMP IS <*>
        JUMPNZ ATCHK         
        LOAD   TSTA, TWO       ; TSTA <- 2, FOR HOMETOWN
        LOAD   PTR, 0014       ; PTR <- 20
        FETCH  COMM, (PTR)     ; COMM <- SCR[20]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR @
ATCHK
        COMP   TEMP, AT        ; CHECK IF TEMP IS <@>
        JUMPNZ ICNT         
        CALL   BINTOHEX        ; UPDATE ASCII COUNTER
        LOAD   TSTA, FIVE      ; TSTA <- 5
        LOAD   TCHK, 0028      ; TCHK <- 40
        LOAD   PTR, 0023       ; PTR <- 35
        FETCH  COMM, (PTR)     ; COMM <- SCR[35]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

ICNT
        COMP   COUNTER, MAX    ; CHECK IF COUNTER IS MAX
        JUMPZ  EISR            ; IF TRUE EXIT
        ADD    COUNTER, ONE    ; INCREMENT COUNTER

TRANS
        OUTPUT COMM, ZEROES    ; TRANSMIT
        FETCH  PTR, 0031       ; PTR <- SCR[65]
        RETEN

; PRINT OUT FROM SCRATCH
PRINT   
        FETCH  PTR, 0030      ; PTR <- 64
        FETCH  COMM, (PTR)    ; COMM <- SCR[64]
        OUTPUT COMM, ZEROES   ; TRANSMIT
        ADD    PTR, ONE       ; INCREMENT PTR ADDRESS
        STORE  PTR, 0030      ; SCR[64] <- PTR
        COMP   PTR, TCHK      ; CHECK IF PTR IS TCHK
        JUMPZ  PMTCHK         ; CHECK TSTA
        JUMP   EISR

PMTCHK
        COMP   TCHK, 0021      ; CHECK IF TCHK IS 33
        JUMPZ  ECHK

        COMP   TCHK, 0014      ; CHECK IF TCHK IS 20
        JUMPNZ PMTCHG          ; CONTINUE TO PRINT PROMPT
        LOAD   COUNTER, ZEROES ; RESET COUNTER FOR NEWLINE 

ECHK
        LOAD   TSTA, ZEROES   ; TSTA <- 0
        FETCH  PTR, 0031      ; PTR <- SCR[65]
        RETEN

PMTCHG
        LOAD   PTR, 000E      ; PTR <- 14
        STORE  PTR, 0030      ; SCR[64] <- PTR
        FETCH  PTR, 0031      ; PTR <- SCR[65]
        LOAD   TSTA, THREE    ; RESET TSTA <- 3
        RETEN

; FALSE INTERRUPT/EXIT
EISR
        FETCH PTR, 0031        ; PTR <- SCR[65]
        RETEN


; PROGRAM ADDRESS
        ADDRESS  0400

; initialize scratch memory[0] with
; (CSULB CECS 460)(14 CHARACTERS)
BANINIT          
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0053 ; LOAD HEX ASCII FOR S TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0055 ; LOAD HEX ASCII FOR U TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004C ; LOAD HEX ASCII FOR L TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0042 ; LOAD HEX ASCII FOR B TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0045 ; LOAD HEX ASCII FOR E TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0053 ; LOAD HEX ASCII FOR S TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0034 ; LOAD HEX ASCII FOR 4 TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0036 ; LOAD HEX ASCII FOR 6 TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0030 ; LOAD HEX ASCII FOR 0 TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[14] with
; (<CR><LF>:~$ )(6 CHARACTERS)
PMTINIT
        LOAD  SCRATCH, 000D ; LOAD HEX ASCII FOR <CR> TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 000A ; LOAD HEX ASCII FOR <LF> TO R0
        CALL  RAMINIT          
        LOAD  SCRATCH, 003A ; LOAD HEX ASCII FOR : TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 007E ; LOAD HEX ASCII FOR ~ TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0024 ; LOAD HEX ASCII FOR $ TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[20] with
; (LONG BEACH)(10 CHARACTERS)
HTINIT          
        LOAD  SCRATCH, 004C ; LOAD HEX ASCII FOR L TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004F ; LOAD HEX ASCII FOR O TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004E ; LOAD HEX ASCII FOR N TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0047 ; LOAD HEX ASCII FOR G TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0042 ; LOAD HEX ASCII FOR B TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0045 ; LOAD HEX ASCII FOR E TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0041 ; LOAD HEX ASCII FOR A TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0048 ; LOAD HEX ASCII FOR H TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[30] with
; (<BS> <BS>)(3 CHARACTERS)
BSINIT        
        LOAD  SCRATCH, 0008 ; LOAD HEX ASCII FOR BS TO R0
        CALL  RAMINIT  
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0008 ; LOAD HEX ASCII FOR BS TO R0
        CALL  RAMINIT
        RETURN


; STORE TO SCRATCH RAM
RAMINIT 
        STORE SCRATCH, (PTR)  
        ADD   PTR, ONE       ; INCREMENT PTR ADDRESS BY 1
        RETURN

; SAY EACH INSTRUCTION FOR NON
; EXCEPT JUMPC TAKES 4 CLOCKS
; AND JUMPC TAKES 5 CLOCKS
; INTERNAL CLOCK IS 100MHZ
; WE DESIRE 25HZ
; SO 100MHZ/25HZ = 4,000,000
; THEN 4,000,000/21 = 190,476
; 190,476 > 65,535 SO 190,476/65,535 ~= 3
; SO 190,476/4 = 47,619 TO GET AN EVEN NUMBER
; 47,619 IS BA03, SO DELAY = BA03
  
; DELAY FUNCTION INBETWEEN LED UPDATES
NON     
        ADD    COUNTN, ONE     ; INCREMENT COUNTN
        NOP
        COMP   COUNTN, DELAY   ; CHECK IF COUNTN IS 47,619
        JUMPC  NON
        LOAD   COUNTN, ZEROES  ; RESET COUNTN
        ADD    NVAL, ONE       ; INCREMENT NVAL
        COMP   NVAL, FOUR      ; CHECK IF NVAL IS 4
        JUMPNZ NON
        LOAD   NVAL, ZEROES    ; RESET NVAL
        RETURN

; BINARY TO HEX ASCII
; CONVERTS COUNTER REGISTER
; TO HEX ASCII FOR EACH DIGIT
; (MULTIPLES OF 10S)
BINTOHEX
         LOAD VALID, ZEROES ; INITIALIZE VALID TO 0
         LOAD PTR, 0023     ; INITIALIZE PTR TO ADDRESS 35
         LOAD DIV, 2710     ; INITIALIZE DIV WITH 10,000
         LOAD QUOT, ZEROES  ; LOAD QUOT WITH 0
         LOAD TEMP, COUNTER ; STORE COUNTER INTO TEMP REGISTER

DIVCHK         
         COMP COUNTER, DIV  ; COMPARE COUNTER TO DIV
         JUMPC CHNGDIV      ; IF COUNTER IS LESS THAN DIV CHANGE DIV
         ADD QUOT, ONE      ; INCREMENT QUOT REGISTER
         SUB COUNTER, DIV   ; SUBTRACT FROM COUNTER CURRENT DIV
         JUMP DIVCHK        ; JUMP TO INITIAL COMPARISON 
         
CHNGDIV  
         COMP VALID, ONE    ; CHECK TO SEE IF VALID
         JUMPZ CONV
         COMP QUOT, ZEROES  ; COMPARE TO ZEROES
         JUMPZ EMPTY
         LOAD VALID, ONE    ; LOAD VALID WITH 1

CONV
         ADD QUOT, 0030     ; CONVERT QUOT TO ASCII
         JUMP CONTI

EMPTY
         ADD QUOT, 0020     ; ADD HEX ASCII SPACE

CONTI
         STORE QUOT, (PTR)  ; STORE QUOT IN SCRATCH
         LOAD QUOT, ZEROES  ; RESET QUOT TO 0 FOR NEXT 10S DIGIT
         ADD PTR, ONE       ; INCREMENT PTR
         COMP DIV, 000A     ; CHECK IF DIV IS 10
         JUMPZ FINAL
         COMP DIV, 0064     ; CHECK IF DIV IS 100
         JUMPZ DIVTEN
         COMP DIV, 03E8     ; CHECK IF DIV IS 1,000
         JUMPZ DIVHUND
         JUMP DIVTHOUD

FINAL    
         ADD QUOT, COUNTER  ; LOAD QUOT WITH REMAINING
         ADD QUOT, 0030     ; CONVERT QUOT TO ASCII
         STORE QUOT, (PTR)  ; STORE QUOT IN SCRATCH
         LOAD PTR, ZEROES   ; RESET PTR TO ADDRESS 0
         LOAD COUNTER, TEMP ; LOAD COUNTER WITH ORIGINAL VALUE
         RETURN

DIVTHOUD 
         LOAD DIV, 03E8     ; LOAD DIV WITH 1,000
         JUMP DIVCHK
         
DIVHUND 
         LOAD DIV, 0064     ; LOAD DIV WITH 100
         JUMP DIVCHK
DIVTEN 
         LOAD DIV, 000A     ; LOAD DIV WITH 100
         JUMP DIVCHK


; ISR VECTORED THROUGH 0FFE
        ADDRESS 0FFE

ENDIT   
        JUMP ISR

END