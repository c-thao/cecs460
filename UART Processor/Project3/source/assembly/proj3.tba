; CHOU THAO
; 012647516
; CECS 460
; TRANSMIT ASSEMBLY
; This assembly code will transmit a banner
; and a prompt on reset and detect four chars
; to indicate whether to print hometown, *,
; print line of characters, @, generate a on
; screen backspace, BS, or print a new prompt
; <CR> else it will echo back a user's input
; up to the 40th character where it will await
; for one of the four above character inputs

; EQU go here for register names
; NUMBER EQUS
ZEROES  EQU 0000 
ONE     EQU 0001
TWO     EQU 0002
THREE   EQU 0003
FOUR    EQU 0004
FIVE    EQU 0005
DELAY   EQU BA03
MAX     EQU 0028
LDCHK   EQU 0080
BS      EQU 0008
CR      EQU 000D
PMTCHK  EQU 0010
BNCHK   EQU 0014
HTCHK   EQU 0020
AST     EQU 002A
AT      EQU 0040

; REGISTER EQUS
SCRATCH EQU R0 ; USED TO STORE INITIAL SCRATCH RAM DATA
PTR     EQU R1 ; POINTER TO STACK RAM
COMM    EQU R3 ; LOAD REGISTER FOR TX & RX
COUNTN  EQU R4 ; NOP COUNTER
COUNTER EQU R5 ; COUNT REGISTER
LEDS    EQU R6 ; LEDS
TEMP    EQU R7 ; TEMP REGISTER
NVAL    EQU R8 ; VALID REGISTER FOR NOP COUNTER
STAT    EQU R9 ; STATUS REGISTER
ERROR   EQU RA ; ERROR REGISTER
TSTA    EQU RB ; TRANSMIT STATE REGISTER
QUOT    EQU RC ; QUOTIENT FROM DIVISION
DIV     EQU RD ; DIVIDER AMOUNT
TCHK    EQU RE ; TRANSMIT CHECK

; INITIALIZATION
; ENABLE INTERRUPTS
START   
        ENINT
        LOAD STAT, ZEROES    ; INITIALIZE STAT WITH 0
        LOAD TSTA, ZEROES    ; INITIALIZE TSTA WITH 0
        LOAD PTR, ZEROES     ; INITIALIZE PTR TO ADDRESS 0
        LOAD COMM, ZEROES    ; INITIALIZE COMM REGISTER TO 0
        LOAD COUNTN, ZEROES  ; INITIALIZE COUNTN REGISTER TO 0
        LOAD COUNTER, ZEROES ; INITIALIZE COUNTER REGISTER TO 0
        LOAD NVAL, ZEROES    ; INITIALIZE NVAL REGISTER TO 0
        LOAD LEDS, ONE       ; INITIALIZE LEDS WITH 1
        CALL BANINIT         ; BANNER INITIALIZATION
        CALL PMTINIT         ; PROMPT INITIALIZATION
        CALL HTINIT          ; HOMETOWN INITIALIZATION
        CALL BSINIT          ; BS INITIALIZATION
        CALL BINTOHEX        ; COUNTER HEXASCII

; main
LOOP
        OUTPUT LEDS, ONE     ; UPDATE LEDS
        COMP   LEDS, LDCHK   ; CHECK IF LEDS ARE AT 8
        JUMPNZ LEDSUP
        LOAD   LEDS, ONE     ; RESET LEDS TO 1
        JUMP   LDOUT

LEDSUP
        RL LEDS              ; ROTATE LEDS TO THE LEFT

LDOUT
        CALL NON             ; CALL DELAY ROUTINE
        JUMP LOOP            
        

; ISR ADDRESS
        ADDRESS 0300

; INTERRUPT SERVICE ROUTINE HANDLES
; TRANSMIT & RECEIVE SUBROUTINES
ISR     
; CHECK IF TRANSMITING EXTRAS
        STORE  PTR, 0031       ; SCR[65] <- PTR
        INPUT  STAT, ONE       ; READ IN STATUS FLAGS

; CHECK IF TXRDY IS HIGH
        LOAD   TEMP, STAT      ; TEMP <- STAT
        COMP   TSTA, FOUR      ; CHECK IF DONE TRANSMITTING
        JUMPZ  RXCHK           ; IF LOW CHECK RXRDY

        AND    TEMP, TWO       ; OBTAIN TXRDY STATUS
        COMP   TEMP, TWO       ; CHECK IF TXRDY HIGH
        JUMPNZ EISR            ; EXIT

PRTCHK
        COMP   TSTA, FIVE      ; CHECK IF TSTA IS 5        
        JUMPZ  PRINT           ; CONTINUE TRANSMIT

; HOMETOWN PRINT
        COMP   TSTA, TWO       ; CHECK IF TSTA IS 2
        JUMPNZ TPRMT           ; ELSE CHECK FOR 3
        LOAD   TCHK, 0020      ; TCHK <- 32
        LOAD   TSTA, FIVE      ; TSTA <- 5
        JUMP   PRINT           ; GO PRINT

; PROMPT PRINT
TPRMT
        COMP   TSTA, THREE     ; CHECK IF TSTA IS 3
        JUMPNZ TBAN            ; ELSE CHECK FOR 4
        LOAD   TCHK, 0016      ; TCHK <- 22
        LOAD   TSTA, FIVE      ; TSTA <- 5
        JUMP   PRINT           ; GO PRINT

; BANNER PRINT
TBAN
        COMP   TSTA, ZEROES    ; CHECK IF TSTA IS 0
        JUMPNZ EISR            ; ELSE EXIT
        LOAD   TCHK, 0010      ; TCHK <- 16
        LOAD   TSTA, FIVE      ; TSTA <- 5
        LOAD   PTR, ZEROES     ; PTR <- 0;
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   PRINT
  
RXCHK
        LOAD   TEMP, STAT      ; TEMP <- STAT      
        AND    TEMP, ONE       ; OBTAIN RXRDY STATUS
        COMP   TEMP, ONE       ; CHECK IF RXRDY HIGH
        JUMPNZ EISR            ; IF LOW RETURN

; OBTAIN ERROR
        LOAD   ERROR, STAT     ; ERROR <- STAT
        AND    ERROR, 001C     ; OBTAIN ERROR STATUS
        SR0    ERROR           ; SHIFT RIGHT TWICE
        SR0    ERROR
        OUTPUT ERROR, TWO      ; UPDATE ERROR STATUS

; READ IN DATA RECEIVED
; AND TRANSMIT IT BACK
        INPUT  COMM, ZEROES    ; READ IN NEW DATA
        LOAD   TEMP, COMM      ; TEMP <- COMM

; CHECK FOR CR
CRCHK
        COMP   TEMP, CR        ; CHECK IF TEMP IS <CR>
        JUMPNZ BSCHK         
        LOAD   TSTA, THREE     ; TSTA <- 3
        LOAD   PTR, 0010       ; PTR <- 16
        FETCH  COMM, (PTR)     ; COMM <- SCR[16]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR BS
BSCHK
        COMP   TEMP, BS        ; CHECK IF TEMP IS <BS>
        JUMPNZ ASTCHK         
        COMP   COUNTER, ZEROES ; CHECK IF COUNTER IS 0
        JUMPZ  EISR            ; EXIT IF TRUE
        LOAD   TSTA, FIVE      ; TSTA <- 5
        SUB    COUNTER, ONE    ; DECREMENT COUNTER
        LOAD   TCHK, 0023      ; TCHK <- 35
        LOAD   PTR, 0020       ; PTR <- 32
        FETCH  COMM, (PTR)     ; COMM <- SCR[30]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR *
ASTCHK
        COMP   TEMP, AST       ; CHECK IF TEMP IS <*>
        JUMPNZ ATCHK         
        LOAD   TSTA, TWO       ; TSTA <- 2, FOR HOMETOWN
        LOAD   PTR, 0016       ; PTR <- 22
        FETCH  COMM, (PTR)     ; COMM <- SCR[22]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

; CHECK FOR @
ATCHK
        COMP   TEMP, AT        ; CHECK IF TEMP IS <@>
        JUMPNZ ICNT         
        CALL   BINTOHEX        ; UPDATE ASCII COUNTER
        LOAD   TSTA, FIVE      ; TSTA <- 5
        LOAD   TCHK, 0029      ; TCHK <- 41
        LOAD   PTR, 0024       ; PTR <- 36
        FETCH  COMM, (PTR)     ; COMM <- SCR[35]
        ADD    PTR, ONE        ; INCREMENT PTR
        STORE  PTR, 0030       ; SCR[64] <- PTR
        JUMP   TRANS

ICNT
        COMP   COUNTER, MAX    ; CHECK IF COUNTER IS MAX
        JUMPZ  EISR            ; IF TRUE EXIT
        ADD    COUNTER, ONE    ; INCREMENT COUNTER

TRANS
        OUTPUT COMM, ZEROES    ; TRANSMIT
        FETCH  PTR, 0031       ; PTR <- SCR[65]
        RETEN

; PRINT OUT FROM SCRATCH
PRINT   
        FETCH  PTR, 0030      ; PTR <- 64
        FETCH  COMM, (PTR)    ; COMM <- SCR[64]
        OUTPUT COMM, ZEROES   ; TRANSMIT
        ADD    PTR, ONE       ; INCREMENT PTR ADDRESS
        STORE  PTR, 0030      ; SCR[64] <- PTR
        COMP   PTR, TCHK      ; CHECK IF PTR IS TCHK
        JUMPZ  PMTCHK         ; CHECK TSTA
        JUMP   EISR

PMTCHK
        COMP   TCHK, 0023      ; CHECK IF TCHK IS 35
        JUMPZ  ECHK

        COMP   TCHK, 0016      ; CHECK IF TCHK IS 22
        JUMPNZ PMTCHG          ; CONTINUE TO PRINT PROMPT
        LOAD   COUNTER, ZEROES ; RESET COUNTER FOR NEWLINE 

ECHK
        LOAD   TSTA, FOUR     ; TSTA <- 4
        FETCH  PTR, 0031      ; PTR <- SCR[65]
        RETEN

PMTCHG
        LOAD   PTR, 0010      ; PTR <- 16
        STORE  PTR, 0030      ; SCR[64] <- PTR
        FETCH  PTR, 0031      ; PTR <- SCR[65]
        LOAD   TSTA, THREE    ; RESET TSTA <- 3
        RETEN

; FALSE INTERRUPT/EXIT
EISR
        FETCH PTR, 0031        ; PTR <- SCR[65]
        RETEN


; PROGRAM ADDRESS
        ADDRESS  0400

; initialize scratch memory[0] with
; (<CR><LF>CSULB CECS 460)(16 CHARACTERS)
BANINIT
        LOAD  SCRATCH, 000D ; LOAD HEX ASCII FOR <CR> TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 000A ; LOAD HEX ASCII FOR <LF> TO R0
        CALL  RAMINIT                    
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0053 ; LOAD HEX ASCII FOR S TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0055 ; LOAD HEX ASCII FOR U TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004C ; LOAD HEX ASCII FOR L TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0042 ; LOAD HEX ASCII FOR B TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0045 ; LOAD HEX ASCII FOR E TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0053 ; LOAD HEX ASCII FOR S TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0034 ; LOAD HEX ASCII FOR 4 TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0036 ; LOAD HEX ASCII FOR 6 TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0030 ; LOAD HEX ASCII FOR 0 TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[16] with
; (<CR><LF>:~$ )(6 CHARACTERS)
PMTINIT
        LOAD  SCRATCH, 000D ; LOAD HEX ASCII FOR <CR> TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 000A ; LOAD HEX ASCII FOR <LF> TO R0
        CALL  RAMINIT          
        LOAD  SCRATCH, 003A ; LOAD HEX ASCII FOR : TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 007E ; LOAD HEX ASCII FOR ~ TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0024 ; LOAD HEX ASCII FOR $ TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[22] with
; (LONG BEACH)(10 CHARACTERS)
HTINIT          
        LOAD  SCRATCH, 004C ; LOAD HEX ASCII FOR L TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004F ; LOAD HEX ASCII FOR O TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 004E ; LOAD HEX ASCII FOR N TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0047 ; LOAD HEX ASCII FOR G TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0042 ; LOAD HEX ASCII FOR B TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0045 ; LOAD HEX ASCII FOR E TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0041 ; LOAD HEX ASCII FOR A TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0043 ; LOAD HEX ASCII FOR C TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0048 ; LOAD HEX ASCII FOR H TO R0
        CALL  RAMINIT
        RETURN

; initialize scratch memory[32] with
; (<BS> <BS>)(3 CHARACTERS)
BSINIT        
        LOAD  SCRATCH, 0008 ; LOAD HEX ASCII FOR BS TO R0
        CALL  RAMINIT  
        LOAD  SCRATCH, 0020 ; LOAD HEX ASCII FOR SPACE TO R0
        CALL  RAMINIT
        LOAD  SCRATCH, 0008 ; LOAD HEX ASCII FOR BS TO R0
        CALL  RAMINIT
        RETURN


; STORE TO SCRATCH RAM
RAMINIT 
        STORE SCRATCH, (PTR)  
        ADD   PTR, ONE       ; INCREMENT PTR ADDRESS BY 1
        RETURN

; SAY EACH INSTRUCTION FOR NON
; EXCEPT JUMPC TAKES 4 CLOCKS
; AND JUMPC TAKES 5 CLOCKS
; INTERNAL CLOCK IS 100MHZ
; WE DESIRE 25HZ
; SO 100MHZ/25HZ = 4,000,000
; THEN 4,000,000/21 = 190,476
; 190,476 > 65,535 SO 190,476/65,535 ~= 3
; SO 190,476/4 = 47,619 TO GET AN EVEN NUMBER
; 47,619 IS BA03, SO DELAY = BA03
  
; DELAY FUNCTION INBETWEEN LED UPDATES
NON     
        ADD    COUNTN, ONE     ; INCREMENT COUNTN
        NOP
        COMP   COUNTN, DELAY   ; CHECK IF COUNTN IS 47,619
        JUMPC  NON
        LOAD   COUNTN, ZEROES  ; RESET COUNTN
        ADD    NVAL, ONE       ; INCREMENT NVAL
        COMP   NVAL, FOUR      ; CHECK IF NVAL IS 4
        JUMPNZ NON
        LOAD   NVAL, ZEROES    ; RESET NVAL
        RETURN

; BINARY TO HEX ASCII
; CONVERTS COUNTER REGISTER
; TO HEX ASCII FOR EACH DIGIT
; (MULTIPLES OF 10S)
BINTOHEX
         LOAD  PTR, 0024      ; INITIALIZE PTR TO ADDRESS 36
         LOAD  DIV, 000A      ; INITIALIZE DIV WITH 10
         LOAD  QUOT, ZEROES   ; LOAD QUOT WITH 0
         LOAD  TEMP, COUNTER  ; STORE COUNTER INTO TEMP REGISTER

DIVCHK         
         COMP  COUNTER, DIV   ; COMPARE COUNTER TO DIV
         JUMPC CHNGDIV        ; IF LESS CHANGE DIV

         ADD   QUOT, ONE      ; INCREMENT QUOT REGISTER
         SUB   COUNTER, DIV   ; SUBTRACT FROM COUNTER CURRENT DIV
         JUMP  DIVCHK         ; JUMP TO INITIAL COMPARISON 
         
CHNGDIV  
         COMP  QUOT, ZEROES
         JUMPZ EMPTY

CONV
         ADD   QUOT, 0030     ; CONVERT QUOT TO ASCII
         JUMP  CONTI

EMPTY
         ADD   QUOT, 0020     ; ADD HEX ASCII SPACE

CONTI
         STORE QUOT, (PTR)    ; STORE QUOT IN SCRATCH
         ADD   PTR, ONE       ; INCREMENT PTR

FINAL    
         LOAD  QUOT, COUNTER  ; LOAD QUOT WITH REMAINING
         ADD   QUOT, 0030     ; CONVERT QUOT TO ASCII
         STORE QUOT, (PTR)    ; STORE QUOT IN SCRATCH
         LOAD  PTR, ZEROES    ; RESET PTR TO ADDRESS 0
         LOAD  COUNTER, TEMP  ; LOAD COUNTER WITH ORIGINAL VALUE
         RETURN


; ISR VECTORED THROUGH 0FFE
        ADDRESS 0FFE

ENDIT   
        JUMP ISR

END
